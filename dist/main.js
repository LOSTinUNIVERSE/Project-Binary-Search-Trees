/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (() => {

eval("/* eslint-disable max-classes-per-file */\n\nconst arrayNumbers = [1, 7, 4, 23, 8, 9, 4, 3, 5, 7, 9, 67, 6345, 324]\n// const arrayNumbers = [1, 7, 4, 23, 8, 9, 4, 3, 5, 7, 1, 1, 1]\n\nconst duplicatesRemoved = function removeDuplicates(array) {\n    return Array.from(new Set(array))\n}\nconst newArray = duplicatesRemoved(arrayNumbers)\nfunction merge(leftArray, rightArray) {\n    let leftIndex = 0\n    let rightIndex = 0\n    const result = []\n    let resultIndex = 0\n\n\n    while (leftIndex < leftArray.length && rightIndex < rightArray.length) {\n        if (leftArray[leftIndex] < rightArray[rightIndex]) {\n            result[resultIndex] = (leftArray[leftIndex])\n            leftIndex++\n            resultIndex++\n        }\n        else {\n            result[resultIndex] = (rightArray[rightIndex])\n            rightIndex++\n            resultIndex++\n        }\n    }\n    while (leftIndex < leftArray.length) {\n        result[resultIndex] = leftArray[leftIndex];\n        leftIndex++;\n        resultIndex++;\n    }\n\n    while (rightIndex < rightArray.length) {\n        result[resultIndex] = rightArray[rightIndex];\n        rightIndex++;\n        resultIndex++;\n    }\n    return result\n}\nconst mergeSort = function (array) {\n    if (array.length <= 1) { return array }\n    const mid = Math.floor(array.length / 2);\n    const leftHalf = array.slice(0, mid);\n    const rightHalf = array.slice(mid);\n\n    const sortedLeft = mergeSort(leftHalf);\n    const sortedRight = mergeSort(rightHalf);\n\n    return merge(sortedLeft, sortedRight)\n}\nconst finalResult = mergeSort(newArray)\nclass Node {\n    constructor(key) {\n        this.key = key\n        this.left = null\n        this.right = null\n    }\n}\n\nconst root = null\nfunction buildTree(array, start, end) {\n    if (start > end) { return null }\n    const mid = Math.floor((start + end) / 2)\n    const node = new Node(array[mid])\n    node.left = buildTree(array, start, mid - 1)\n    node.right = buildTree(array, mid + 1, end)\n    return node\n}\n\nclass Tree {\n    constructor(array, start, end) {\n        this.root = buildTree(array, start, end)\n    }\n}\nconst n = finalResult.length\nconst tree = new Tree(finalResult, 0, n - 1)\n// console.log(tree);\n\n\nfunction insert(node, key) {\n    if (node == null) {\n        return node\n    }\n    console.log(node);\n\n    if (key > node.key) return insert(node.right, key)\n    return insert(node.left, key);\n}\n\nfunction deleteRec(root, key) {\n    if (root == null) { return root; }\n    if (key < root.key) {\n        root.left = deleteRec(root.left, key);\n        return root\n    }\n\n    if (key > root.key) {\n        root.right = deleteRec(root.right, key);\n        return root\n    }\n\n    if (root.left == null) {\n        const temp = root.right\n        return temp\n    }\n    if (root.right == null) {\n        const temp = root.left\n        return temp\n    }\n    // eslint-disable-next-line no-else-return\n    else {\n        let succParent = root\n        let succ = root.right\n        while (succ.left != null) {\n            succParent = succ\n            succ = succ.left\n        }\n\n        if (succParent != root) {\n            succParent.left = succ.right;\n        }\n        else { succParent.right = succ.right; }\n\n        root.key = succ.key;\n\n        return root;\n    }\n}\nconst deletedResult = deleteRec(tree.root, 8)\n\nfunction findNode(node, key) {\n    if (node == null) return node\n    if (key > node.key) return findNode(node.right, key)\n    if (key < node.key) return findNode(node.left, key)\n    if (key == node.key) return node\n}\nconst foundNode = findNode(tree.root, 7)\n\n\nfunction breadthFirstSearch(root, visitFn = node => node.data) {\n    const result = []\n    const queue = [root]\n\n    while (queue.length > 0) {\n        const current = queue.shift()\n        if (current == null) continue;\n        result.push(current.key)\n        if (current.left != null) queue.push(current.left)\n        if (current.right != null) queue.push(current.right)\n    }\n    return result\n}\n// const result = breadthFirstSearch(tree.root)\n// console.log(result);\n\nfunction inOrder(node, data = []) {\n    if (node == null) return node\n    inOrder(node.left, data)\n    data.push(node.key)\n    inOrder(node.right, data)\n    return data\n}\n\n// console.log(inOrderData);\n\n\nfunction preOrder(node, data = [], visitFn = node => node.key) {\n    if (node == null) return node\n    data.push(node.key)\n    preOrder(node.left, data)\n    preOrder(node.right, data)\n    return data\n}\n\n// console.log(preOrderData);\n\nfunction postOrder(node, data = [], visitFn = node => node.key) {\n    if (node == null) return node\n    postOrder(node.left, data)\n    postOrder(node.right, data)\n    data.push(node.key)\n    return data\n}\n\n// console.log(postOrderData);\nconst counter = 0\nconst defineDepth = function (node, counter = 0) {\n    if (node == null) return counter\n    counter += 1\n    if (node.left != null) defineDepth(node.left)\n    if (node.right != null) defineDepth(node.right)\n    // console.log(counter);\n    return counter\n}\n// const depthOfNode = defineDepth(foundNode)\n// console.log(depthOfNode);\n\nlet heightCounter = 0\nfunction defineHeight(node, key) {\n    if (node == null) return heightCounter\n    heightCounter++\n    if (key > node.key) return defineHeight(node.right, key)\n\n    if (key < node.key) return defineHeight(node.left, key)\n\n    if (key == node.key) return heightCounter\n    return heightCounter\n}\nconst heightOfNode = defineHeight(tree.root, 4)\n\nfunction height(node) {\n    if (node == null) return 0\n    return Math.max(height(node.left), height(node.right)) + 1\n}\n\nconst isBalanced = function (node) {\n    if (node == null) return true\n    const lh = height(node.left)\n    const rh = height(node.right)\n\n    if (Math.abs(lh - rh) <= 1 && isBalanced(\n        node.left) == true && isBalanced(node.right) == true)\n        return true\n\n    return false\n\n}\n\n\nconst balanceTree = function () {\n    const orderData = inOrder(tree.root)\n    console.log(orderData);\n    const newTree = new Tree(orderData, 0, n - 1)\n    return newTree\n}\n// const newTree = balanceTree()\nconst something = new Tree(finalResult, 0, n - 1)\nconsole.log(isBalanced(tree.root));\n// const postOrderData = postOrder(tree.root)\n// const preOrderData = preOrder(tree.root)\n// const inOrderData = inOrder(tree.root)\nconst nodeTOChange = insert(tree.root, 10)\n\n\n\n\n//# sourceURL=webpack://template/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"]();
/******/ 	
/******/ })()
;